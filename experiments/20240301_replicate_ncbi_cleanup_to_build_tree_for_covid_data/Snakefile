import os 

reference_sequence = "data/reference.fasta"
input_fasta1 = "data/deer_covid.fasta",
input_fasta2 = "data/omicron.fasta"
output_dir = "results"

rule all:
    input:
        results = os.path.join(output_dir, "iqtree_fixed_internal.nwk"),
        difFUBAR_input_fasta = os.path.join(output_dir, "mafft_alignment_removed_tags.fasta")
        #results = os.path.join(output_dir, "mafft_alignment.fasta")
        #nextclade_results ="results/nextclade_output/nextclade.tsv",

rule combine_fasta:
    message:
        """
        Combining {input.reference_sequence}, {input.fasta1} and {input.fasta2}. The first seqeunce is the reference sequence and will be used to root the tree with iqtree2 when building the tree
        """
    input:
        reference_sequence = reference_sequence,
        fasta1 = input_fasta1,
        fasta2 = input_fasta2
    output:
        combined_fasta = os.path.join(output_dir, "combined.fasta")    
    shell:
        """
        cat {input.reference_sequence} {input.fasta1} {input.fasta2} > {output.combined_fasta}
        """

rule process_fasta:
    message:
        """
        Pre-processing fasta file.
        """
    input:
        fasta_file = rules.combine_fasta.output
    params:
        group1_n = 100,
        group2_n = 80,
        group1 = "human",
        group2 = "deer"
    output:
        output = os.path.join(output_dir, "combined_transformed.fasta"),
        output_tagged = os.path.join(output_dir, "combined_transformed_tagged.fasta")
    shell:
        "python process_fasta.py {input.fasta_file} --group1 {params.group1} --group2 {params.group2} --group1_n {params.group1_n} --group2_n {params.group2_n} --output {output.output} --output_tagged {output.output_tagged}"

#rule fix_fasta_tag:
#    input:
#        fasta_file = rules.process_fasta.output.output_tagged
#    output:
#        fasta_file = os.path.join(output_dir, "combined_transformed_tagged_fixed.fasta")
#    shell:
#        "python fix_tree_tags.py {input.fasta_file} {output.fasta_file}"

rule sequence_alignment_mafft:
    input:
        fasta_file = rules.process_fasta.output.output_tagged
        #fasta_file = rules.fix_fasta_tag.output
    output:
        output = os.path.join(output_dir, "mafft_alignment.fasta")
    shell:
        "mafft --auto {input.fasta_file} > {output.output}"

rule build_tree:
    input:
        fasta_file = rules.sequence_alignment_mafft.output
    params:
        #output = os.path.join(output_dir, "tree_raw.nwk")
        prefix = "iqtree"
    output:
        output = os.path.join(output_dir, "iqtree.log")
    shell:
        "iqtree2 -s {input.fasta_file} -pre {params.prefix} | tee {output.output}"

rule fix_tag:
    input:
        tree_file = os.path.join(output_dir, "iqtree.treefile")
    output:
        tree_file = os.path.join(output_dir, "iqtree_fixed.nwk")
    shell:
        """
        python fix_tree_tags.py {input.tree_file} {output.tree_file}
        """
rule fix_tag_fasta:
    input:
        fasta_file = rules.sequence_alignment_mafft.output
    output:
        fasta_file = os.path.join(output_dir, "mafft_alignment_fixed_tags.fasta"),
    shell:
        """
        python fix_tree_tags.py {input.fasta_file} {output.fasta_file}
        """

rule remove_tag_fasta:
    input:
        fasta_file = rules.fix_tag_fasta.output
    output:
        fasta_file = os.path.join(output_dir, "mafft_alignment_removed_tags.fasta"),
    shell:
        """
        python remove_tags.py {input.fasta_file} {output.fasta_file}
        """


rule tag_internal_nodes:
    input:
        tree_file = rules.fix_tag.output
    output:
        tree_file = os.path.join(output_dir, "iqtree_fixed_internal.nwk")
    shell:
        """
        julia tag_internal_nodes.jl -i {input.tree_file} -o {output.tree_file}
        """


